{"version":3,"sources":["markdown_to_hiccup/core.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.core/string?","cljs.core/vector?","cljs.spec.alpha/map-spec-impl","G__22208","cljs.core/map?","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl","cljs.spec.alpha/cat-impl","var_args","G__22285","markdown-to-hiccup.core/md->hiccup","js/Error","md-str","params","valid-md","cljs.spec.alpha/*compile-asserts*","cljs.core/deref","cljs.spec.alpha/*runtime-asserts*","cljs.spec.alpha/assert*","encode?","html","markdown.core/md->html","dom","hickory.core/parse","hiccup","cljs.core/first","hickory.core/as-hiccup","markdown-to-hiccup.decode/decode","markdown_to_hiccup.core.md__GT_hiccup","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","markdown-to-hiccup.core/hicc-in","seq22286","G__22287","cljs.core/next","self__4851__auto__","kws","kw","root","cljs.core/empty?","cljs.core/rest","branch-result","cljs.core.apply","cljs.core._EQ_","markdown-to-hiccup.core/keywords?","seq22288","self__4852__auto__","cljs.core/seq","args","cljs.core/every?","cljs.core/keyword?","markdown-to-hiccup.core/dec-front","kw-pairs","vec__22289","cljs.core.nth","count","new-count","new-pair","cljs.core/cons","markdown-to-hiccup.core/num-partition","arglist","ret-vec","curr-arg","prev-arg","cljs.core/peek","cljs.core/Keyword","cljs.core.partition","cljs.core.conj","markdown_to_hiccup.core.keywords_QMARK_","markdown-to-hiccup.core/same-length?","coll-a","coll-b","cljs.core/count","markdown-to-hiccup.core/get-nested-hiccup","vec__22292","nth-kw","front","remaining","nested-front","new-pairs","markdown-to-hiccup.core/hiccup-in","seq22295","G__22296","pathway","markdown-to-hiccup.core/component","body","markdown_to_hiccup.core.hiccup_in","cljs.core/vec"],"sourcesContent":["(ns markdown-to-hiccup.core\n  (:require [clojure.string :as str]\n            [clojure.spec.alpha :as spec]\n            [markdown-to-hiccup.decode :as d]\n            [hickory.core :refer [parse as-hiccup]]\n            [markdown.core :refer #?(:clj  [md-to-html-string]\n                                     :cljs [md->html])]))\n\n(spec/def ::markdown string?)\n(spec/def ::hiccup vector?)\n(spec/def ::options (spec/keys :opt-un [::encode?]))\n(spec/fdef md->hiccup\n           :args (spec/cat :md-str ::markdown\n                           :params ::options)\n           :ret ::hiccup)\n(defn md->hiccup\n  \"Accepts a markdown string and returns a hiccup data structure converted from that markdown.\n  Also accepts an optional params map. Use the :encode? boolean key to specify whether\n  or not you want html escape characters to be encoded. Example:\n    (md->hiccup \\\"#Title\\\" {:encode? true})\"\n  ([md-str params]\n   (let [valid-md (spec/assert ::markdown md-str)\n         encode? (:encode? (spec/assert ::options params))\n         html #?(:clj  (md-to-html-string valid-md)\n                 :cljs (md->html valid-md))\n         dom  (parse html)\n         hiccup (first (as-hiccup dom))]\n     (if encode?\n       hiccup ;; by default encoded by hickory\n       (d/decode hiccup))))\n  ([md-str]\n   (md->hiccup md-str {:encode? false})))\n   \n(defn hicc-in\n  \"Deprecated. Please use hiccup-in for better access to nested hiccup.\n  Accepts a hiccup data structure and a keyword representing\n  an html element tag (e.g. :body) and returns the first nested\n  hiccup vector identified by the keyword.\"\n  [hiccup & kws]\n  (let [kw   (first kws)\n        root (first hiccup)]\n    (cond\n      (nil? kw)              hiccup\n      (empty? hiccup)        []\n      (map? root)            (recur (rest hiccup) kws)\n      (vector? root)         (let [branch-result (apply hicc-in root kws)]\n                               (if (empty? branch-result)\n                                 (recur (rest hiccup) kws)\n                                 branch-result))\n      (= root kw)            (recur hiccup (rest kws))\n      :else                  (recur (rest hiccup) kws))))\n\n(defn- keywords?\n  [& args]\n  (every? keyword? args))\n\n(defn- dec-front\n  \"Accepts a list of [keyword count] pairs, and subtracts the count\n   of the first pair. If that count becomes negative, dec-front returns\n   the rest of the list. Otherwise, it returns the list with the new\n   count value for the first pair.\"\n  [kw-pairs]\n  (let [[kw count] (first kw-pairs)\n        new-count  (dec count)\n        new-pair   [kw new-count]]\n    (if (neg? new-count)\n      (rest kw-pairs)\n      (cons new-pair (rest kw-pairs)))))\n\n(defn- num-partition\n  \"Accepts a list of keywords and numbers. Any place in which\n  a number does not separate keywords, a zero will be inserted.\n  Returns the arg list as a sequence of keyword -> number pairs\n  nested as lists.\"\n  [args]\n  (loop [arglist    args\n         ret-vec   []]\n    (let [curr-arg (first arglist)\n          prev-arg (peek ret-vec)]\n      (cond\n        ;; base case\n        (nil? curr-arg)            (if (keyword? prev-arg)\n                                     (partition 2 (conj ret-vec 0))\n                                     (partition 2 ret-vec))\n        ;; recursive cases\n        (keywords? curr-arg\n                   prev-arg)       (recur (rest arglist)\n                                          (conj ret-vec 0 curr-arg))\n\n        :else                      (recur (rest arglist)\n                                          (conj ret-vec curr-arg))))))\n\n\n(defn- same-length?\n  [coll-a coll-b]\n  (= (count coll-a)\n     (count coll-b)))\n\n(defn- get-nested-hiccup\n  \"Recursive helper function for hiccup-in.\"\n  [hiccup kw-pairs]\n  (let [[kw nth-kw]   (first kw-pairs)\n        front         (first hiccup)\n        remaining     (rest hiccup)]\n    (cond\n      (empty? hiccup)        []\n      (nil? kw)              hiccup\n      (map? front)           (recur remaining kw-pairs)\n      (vector? front)        (let [branch-result (get-nested-hiccup front kw-pairs)]\n                               (if (empty? branch-result)\n                                 (let [nested-front (first front)]\n                                   (if (= nested-front kw) ;; the child recurse did find a match, but we need to update our kw-pair list if the first element had a match\n                                    (recur remaining (dec-front kw-pairs))\n                                    (recur remaining kw-pairs)))\n                                 branch-result))\n      (= front kw)           (let [new-pairs (dec-front kw-pairs)]\n                               (cond\n                                 (empty? new-pairs)                  hiccup                         ;; no keywords left, return what we have found\n                                 :else                               (recur remaining new-pairs)))  ;; prceed to the next instance of the keyword\n      :else                  (recur remaining kw-pairs))))\n\n\n\n(defn hiccup-in\n  \"Accepts a hiccup data structure and any series of args in keyword, index order.\n   Each keyword represents a hiccup element, and the paired index is which element at that level hiccup-in will look in.\n   If no number proceeds a keyword, hiccup-in will find the first element with that keyword.\n   Returns the nested hiccup vector identified by the keywords.\n   Example: (hiccup-in hiccup :html :body :div 0 :h1 2 :p)\"\n  [hiccup & kw-pairs]\n   (let [pathway (num-partition kw-pairs)]\n     (get-nested-hiccup hiccup pathway)))\n\n(defn component\n  \"Accepts hiccup and returns the same hiccup only\n   without the :html, :head, and :body elements. Useful\n   if you want to nest your markdown hiccup in existing\n   hiccup data structures.\"\n  [hiccup]\n  (let [body (hiccup-in hiccup :body)]\n    (vec (cons :div (rest body)))))\n\n#?(:clj\n  (defn file->hiccup\n  \"Generates a valid hiccup data structure from markdown\n   contained in the .md file located at file-path\"\n  [file-path]\n  (let [contents (slurp file-path)]\n    (md->hiccup contents))))\n"]}